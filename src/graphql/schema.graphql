"""
The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
    """
    If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to.
    """
    label: String

    """
    Deferred when true.
    """
    if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
    """
    If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to.
    """
    label: String

    """
    The initial elements that shall be send down to the consumer.
    """
    initialCount: Int! = 0

    """
    Streamed when true.
    """
    if: Boolean
) on FIELD

directive @authorize(
    """
    The name of the authorization policy that determines access to the annotated resource.
    """
    policy: String

    """
    Roles that are allowed to access the annotated resource.
    """
    roles: [String!]

    """
    Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field.
    """
    apply: ApplyPolicy! = BEFORE_RESOLVER
) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

enum ApplyPolicy {
    BEFORE_RESOLVER
    AFTER_RESOLVER
}

type Query {
    login(login: LoginInfoInput!): String!
    participants: [Participant!]!
    settings: Settings!
    statistics: Statistics!
    emailStatistics: EmailStatistics!
}

type Mutation {
    addParticipant(newParticipant: NewParticipantInput!): Participant!
    updateParticipant(
        id: Int!
        updateParticipant: UpdateParticipantInput!
    ): Participant!
    updateParticipants(
        updateParticipants: [UpdateParticipantsItemInput!]!
    ): [Participant!]!
    updateSettings(updateSettings: UpdateSettingsInput!): Settings!
    addAdmin(login: RegistrationInfoInput!): Int!
    removeParticipant(id: Int!): Boolean!
    statusAction(id: Int!, presumedStatus: ParticipantStatus!): Boolean!
    statusActionAllOfStatus(expectedStatus: ParticipantStatus!): Boolean!
}

type Participant {
    id: Int!
    participantName: String!
    participantSurname: String!
    parentName: String!
    parentSurname: String!
    school: String!
    phone: String!
    email: String!
    ip: String!
    variableSymbol: String!
    signUpDate: DateTime!
    dueDate: DateTime!
    paidDate: DateTime
    isPaid: Boolean!
    isOver: Boolean!
    creationNotified: Boolean!
    cancelationNotified: Boolean!
    paidNotified: Boolean!
    status: ParticipantStatus!
}

input LoginInfoInput {
    username: String!
    password: String!
}

type Settings {
    id: Int!
    signUpAllowed: Boolean!
    signUpUntil: Date!
    signUpFrom: Date!
    capacity: Int!
    allowedOver: Int!
}

type Statistics {
    totalSignups: Int!
    capacity: Int!
    remainingCapacity: Int!
    remainingCapacityOver: Int!
    removedSignups: Int!
}

type EmailStatistics {
    accepted: Int!
    withoutPaymentConfirmationEmail: Int!
    withoutCancelationConfirmationEmail: Int!
    waitingForPayment: Int!
    canceled: Int!
    withoutEmailNotifyingOfFreeSpot: Int!
}

input NewParticipantInput {
    participantName: String!
    participantSurname: String!
    parentName: String!
    parentSurname: String!
    school: String!
    phone: String!
    email: String!
}

input UpdateParticipantInput {
    participantName: String
    participantSurname: String
    parentName: String
    parentSurname: String
    school: String
    phone: String
    email: String
    paidDate: DateTime
}

input UpdateParticipantsItemInput {
    id: Int!
    data: UpdateParticipantInput!
}

input UpdateSettingsInput {
    signUpAllowed: Boolean!
    capacity: Int!
    allowedOver: Int!
    signUpUntil: Date!
    signUpFrom: Date!
}

input RegistrationInfoInput {
    username: String!
    password: String!
    email: String!
}

enum ParticipantStatus {
    NOT_NOTIFIED
    UNPAID
    UNPAID_LATE
    CANCELED
    PAID_UNCONFIRMED
    PAID_CONFIRMED
    ERROR
}

"""
The `Date` scalar represents an ISO-8601 compliant date type.
"""
scalar Date

"""
The `DateTime` scalar represents an ISO-8601 compliant date time type.
"""
scalar DateTime
